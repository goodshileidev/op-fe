# 废弃方案历史记录

**文档编号**: KB-003
**创建时间**: 2025-11-26 15:05
**最后修改**: 2025-11-26 15:05
**执行模型**: claude-opus-4-1 (claude-opus-4-1-20250805)
**文档状态**: 生效中

---

## 修改历史

| 日期 | 修改人/模型 | 修改概要 |
|------|------------|---------|
| 2025-11-26 15:05 | claude-opus-4-1 | 从deprecated目录迁移并整理 |
| 2025-01-14 | 开发团队 | 废弃v1.0方案 |

---

## 概述

本文档记录项目历史上被废弃的技术方案，作为经验教训和决策参考。通过记录失败的尝试，帮助团队避免重复错误，理解技术演进过程。

---

## 废弃方案 v1.0：Entity重写方案 (2025-01-14)

### 方案概述

v1.0方案试图通过完全重写数据模型来实现通用化：
- 引入Entity/EntityTemplate/EntityField等新概念
- 重构所有数据表
- 全面重写业务逻辑

### 废弃原因

经过详细评审，发现以下严重问题：

#### 1. 概念设计问题

**概念混乱**
- Entity、FormInstance、Document概念不清，自相矛盾
- 字段在多处重复存储（Document.customFields + EntityFieldValue）
- 数据模型关系混乱

**过度设计**
- 引入大量抽象层（Engine、Manager、Registry等）
- 过度工程化，增加不必要的复杂度
- 简单问题复杂化

#### 2. 技术实现问题

**数据模型缺陷**
- 字段数量爆炸：从13个增加到40+个
- customFields使用JSON，失去类型安全
- 数据冗余严重

**安全问题**
```javascript
// ❌ 危险：使用eval执行用户输入
const result = eval(rule.expression);
```

**类型系统滥用**
```typescript
// ❌ 错误：绕过类型检查
return oldData as EntityData as any as FormInstance;
```

#### 3. 工程问题

**时间估算严重错误**
- 声称16周完成
- 实际需要6-12个月
- 未考虑数据迁移复杂度

**配置地狱**
- 单个场景配置高达1677行JSON
- 无法维护和理解
- 配置错误难以排查

**兼容性虚假**
- 声称100%向后兼容
- 实际使用 `as any` 绕过类型检查
- 无法保证运行时兼容性

### 具体问题示例

#### 示例1：字段重复存储
```typescript
// ❌ 同一个字段在多处存储
Document.customFields.patientName = "张三"
EntityFieldValue { fieldId: 123, value: "张三" }
// 数据不一致风险
```

#### 示例2：验证逻辑错误
```typescript
// ❌ 永远返回true
validate(value: any, rule: ValidationRule): boolean {
  if (rule.required && !value) {
    return false;
  }
  // 忘记了其他规则...
  return true;  // ❌ 应该继续检查其他规则
}
```

#### 示例3：配置复杂度
```json
{
  "scenario": {
    "fields": {
      // ... 1600+ 行配置 ...
    }
  }
}
```

### 经验教训

1. **避免推倒重来** - 渐进式改造风险更低
2. **POC先行** - 先验证可行性
3. **保持简单** - 复杂的抽象往往不必要
4. **重视向后兼容** - 迁移成本不可忽视
5. **合理估算时间** - 考虑所有环节

---

## 对比分析：v1.0 vs v2.0

| 维度 | v1.0 (废弃) | v2.0 (采用) | 差异分析 |
|------|------------|------------|----------|
| **核心理念** | 推倒重来 | 渐进改造 | v2.0更务实 |
| **数据模型** | 重写为Entity | 保持Document/Form | 零迁移成本 |
| **实施策略** | 一次性重构 | POC + 迭代 | 降低风险 |
| **时间周期** | 16周(错误) | 4周POC + 渐进 | 更快见效 |
| **数据迁移** | 全量迁移 | 零迁移 | 避免风险 |
| **配置量** | 1677行/场景 | 50-150行/场景 | 10倍简化 |
| **技术债务** | 引入大量新债务 | 最小化新概念 | 降低复杂度 |
| **向后兼容** | 虚假兼容 | 100%兼容 | 真正兼容 |
| **可行性** | 低 | 高 | 已验证 |

---

## 废弃文档清单

以下v1.0方案相关文档已被废弃：

| 文档名称 | 内容概述 | 主要问题 |
|---------|---------|---------|
| generic-data-model.md | Entity数据模型设计 | 概念混乱，字段冗余 |
| universal-transformation-plan.md | 通用化改造计划 | 过度设计，时间错误 |
| form-template-refactor.md | 模板系统重构 | 类型系统滥用any |
| 01-data-model-refactor.md | 数据模型重构详细设计 | 字段爆炸问题 |
| 02-scenario-manager.md | 场景管理器设计 | 过度抽象 |
| 03-field-type-system.md | 字段类型系统 | 复杂度过高 |
| 04-rule-engine.md | 规则引擎设计 | eval安全漏洞 |
| 05-form-renderer.md | 表单渲染器 | 依赖错误模型 |
| 06-scenario-configuration.md | 场景配置规范 | 1677行JSON |
| 07-data-migration.md | 数据迁移方案 | 低估复杂度 |

---

## 为什么记录失败

记录失败的方案有重要价值：

### 1. 避免重复错误
- 新团队成员能了解历史
- 避免走回老路
- 节省探索成本

### 2. 决策透明
- 展示决策过程
- 理解技术选择原因
- 建立团队信任

### 3. 知识积累
- 失败也是经验
- 某些思路仍有参考价值
- 促进技术成长

### 4. 持续改进
- 从失败中学习
- 优化决策流程
- 提升架构能力

---

## 正确的做法参考

基于失败经验，正确的做法应该：

### 设计原则
- ✅ 简单优先，避免过度设计
- ✅ POC验证，快速试错
- ✅ 渐进改造，小步快跑
- ✅ 保持兼容，降低风险

### 技术选择
- ✅ 使用成熟方案
- ✅ 避免重复造轮子
- ✅ 合理使用抽象
- ✅ 重视类型安全

### 项目管理
- ✅ 合理估算时间
- ✅ 分阶段交付
- ✅ 持续获取反馈
- ✅ 及时调整方向

---

## 当前有效方案

### v2.0 场景适配层方案
- 文档：`docs/02-需求/TRANSFORMATION_OVERVIEW.md`
- 状态：实施中
- 特点：渐进式、低风险、快速见效

### v3.0 产品化改造方案
- 文档：`docs/02-需求/PRODUCT_TRANSFORMATION_PLAN.md`
- 状态：规划中
- 特点：更彻底的产品化

---

## 总结

失败是成功之母。通过记录和分析失败的方案，我们能够：
- 理解什么方法不可行
- 避免重复同样的错误
- 积累宝贵的经验教训
- 做出更好的技术决策

**记住**：简单的方案往往是最好的方案。

---

**本文档将持续更新，记录更多的经验教训。**